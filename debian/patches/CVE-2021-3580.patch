From: Markus Koschany <apo@debian.org>
Date: Sat, 18 Sep 2021 16:06:58 +0200
Subject: CVE-2021-3580

Backport the new input in range checks and tests only which are needed to fix
CVE-2021-3580.

Bug-Debian: https://bugs.debian.org/989631
Origin: https://git.lysator.liu.se/nettle/nettle/-/commit/0ad0b5df315665250dfdaa4a1e087f4799edaefe
---
 rsa-decrypt-tr.c             |  4 ++++
 rsa-decrypt.c                | 10 ++++++++++
 rsa.h                        |  3 ++-
 testsuite/rsa-encrypt-test.c | 35 +++++++++++++++++++++++++++++++++--
 4 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/rsa-decrypt-tr.c b/rsa-decrypt-tr.c
index 312b182..bc79ee8 100644
--- a/rsa-decrypt-tr.c
+++ b/rsa-decrypt-tr.c
@@ -43,6 +43,10 @@ rsa_decrypt_tr(const struct rsa_public_key *pub,
   mpz_t m, ri;
   int res;
 
+  /* First check that input is in range. */
+  if (mpz_sgn (gibberish) < 0 || mpz_cmp (gibberish, pub->n) >= 0)
+    return 0;
+
   mpz_init_set(m, gibberish);
   mpz_init (ri);
 
diff --git a/rsa-decrypt.c b/rsa-decrypt.c
index a3abf6e..5ad9514 100644
--- a/rsa-decrypt.c
+++ b/rsa-decrypt.c
@@ -40,6 +40,16 @@ rsa_decrypt(const struct rsa_private_key *key,
   int res;
 
   mpz_init(m);
+
+  /* First check that input is in range. Since we don't have the
+     public key available here, we need to reconstruct n. */
+  mpz_mul (m, key->p, key->q);
+  if (mpz_sgn (gibberish) < 0 || mpz_cmp (gibberish, m) >= 0)
+    {
+      mpz_clear (m);
+      return 0;
+    }
+
   rsa_compute_root(key, m, gibberish);
 
   res = pkcs1_decrypt (key->size, m, length, message);
diff --git a/rsa.h b/rsa.h
index 4226f38..2a11ff5 100644
--- a/rsa.h
+++ b/rsa.h
@@ -302,7 +302,8 @@ rsa_decrypt_tr(const struct rsa_public_key *pub,
 	       unsigned *length, uint8_t *message,
 	       const mpz_t gibberish);
 
-/* Compute x, the e:th root of m. Calling it with x == m is allowed. */
+/* Compute x, the e:th root of m. Calling it with x == m is allowed.
+   It is required that 0 <= m < n. */
 void
 rsa_compute_root(const struct rsa_private_key *key,
 		 mpz_t x, const mpz_t m);
diff --git a/testsuite/rsa-encrypt-test.c b/testsuite/rsa-encrypt-test.c
index c7b616c..077a9d2 100644
--- a/testsuite/rsa-encrypt-test.c
+++ b/testsuite/rsa-encrypt-test.c
@@ -19,10 +19,12 @@ test_main(void)
   uint8_t after;
 
   mpz_t gibberish;
+  mpz_t bad_input;
 
   rsa_private_key_init(&key);
   rsa_public_key_init(&pub);
   mpz_init(gibberish);
+  mpz_init(bad_input);
 
   knuth_lfib_init(&lfib, 17);
   
@@ -61,12 +63,13 @@ test_main(void)
   knuth_lfib_random (&lfib, msg_length + 1, decrypted);
   after = decrypted[msg_length];
 
+
   decrypted_length = key.size;
   ASSERT(rsa_decrypt(&key, &decrypted_length, decrypted, gibberish));
   ASSERT(decrypted_length == msg_length);
   ASSERT(MEMEQ(msg_length, msg, decrypted));
   ASSERT(decrypted[msg_length] == after);
-  
+
   knuth_lfib_random (&lfib, msg_length + 1, decrypted);
   after = decrypted[msg_length];
 
@@ -78,9 +81,37 @@ test_main(void)
   ASSERT(MEMEQ(msg_length, msg, decrypted));
   ASSERT(decrypted[msg_length] == after);
 
+  /* Test zero input. */
+  mpz_set_ui (bad_input, 0);
+  decrypted_length = msg_length;
+  ASSERT(!rsa_decrypt(&key, &decrypted_length, decrypted, bad_input));
+  ASSERT(!rsa_decrypt_tr(&pub, &key,
+			 &lfib, (nettle_random_func *) knuth_lfib_random,
+			 &decrypted_length, decrypted, bad_input));
+  ASSERT(decrypted_length == msg_length);
+
+  /* Test input that is slightly larger than n */
+  mpz_add(bad_input, gibberish, pub.n);
+  decrypted_length = msg_length;
+  ASSERT(!rsa_decrypt(&key, &decrypted_length, decrypted, bad_input));
+  ASSERT(!rsa_decrypt_tr(&pub, &key,
+			 &lfib, (nettle_random_func *) knuth_lfib_random,
+			 &decrypted_length, decrypted, bad_input));
+  ASSERT(decrypted_length == msg_length);
+
+  /* Test input that is considerably larger than n */
+  mpz_mul_2exp (bad_input, pub.n, 100);
+  mpz_add (bad_input, bad_input, gibberish);
+  decrypted_length = msg_length;
+  ASSERT(!rsa_decrypt(&key, &decrypted_length, decrypted, bad_input));
+  ASSERT(!rsa_decrypt_tr(&pub, &key,
+			 &lfib, (nettle_random_func *) knuth_lfib_random,
+			 &decrypted_length, decrypted, bad_input));
+  ASSERT(decrypted_length == msg_length);
+
   rsa_private_key_clear(&key);
   rsa_public_key_clear(&pub);
   mpz_clear(gibberish);
+  mpz_clear(bad_input);
   free(decrypted);
 }
-  
